package com.ericsson.eniq.techpacksdk.view.universeParameters;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;
import java.util.logging.Logger;

import ssc.rockfactory.RockDBObject;
import ssc.rockfactory.RockException;
import ssc.rockfactory.RockFactory;

import com.distocraft.dc5000.repository.dwhrep.Universeclass;
import com.distocraft.dc5000.repository.dwhrep.UniverseclassFactory;
import com.distocraft.dc5000.repository.dwhrep.Universecomputedobject;
import com.distocraft.dc5000.repository.dwhrep.UniversecomputedobjectFactory;
import com.distocraft.dc5000.repository.dwhrep.Universecondition;
import com.distocraft.dc5000.repository.dwhrep.UniverseconditionFactory;
import com.distocraft.dc5000.repository.dwhrep.Universename;
import com.distocraft.dc5000.repository.dwhrep.UniversenameFactory;
import com.distocraft.dc5000.repository.dwhrep.Universeobject;
import com.distocraft.dc5000.repository.dwhrep.UniverseobjectFactory;
import com.distocraft.dc5000.repository.dwhrep.Universeparameters;
import com.distocraft.dc5000.repository.dwhrep.UniverseparametersFactory;
import com.distocraft.dc5000.repository.dwhrep.Versioning;
import com.distocraft.dc5000.repository.dwhrep.VersioningFactory;
import com.ericsson.eniq.component.DataTreeNode;
import com.ericsson.eniq.component.ExceptionHandler;
import com.ericsson.eniq.techpacksdk.common.Constants;
import com.ericsson.eniq.techpacksdk.datamodel.DataModel;
import com.ericsson.eniq.techpacksdk.datamodel.DataModelController;

public class UniverseClassDataModel implements DataModel {

  /**
   * 
   */
  private static final long serialVersionUID = 1L;

  private static final Logger logger = Logger.getLogger(UniverseClassView.class.getName());

  private Versioning versioning;

  RockFactory etlRock;

  private UniverseClassTableModel uctm;

  DataModelController dataModelController = null;

  Universeclass universeclass;

  public UniverseClassDataModel(RockFactory etlRock) {

    this.etlRock = etlRock;
    try {
      this.uctm = createUCTableModel(null);
    } catch (Exception e) {
      logger.warning("Could not set TableModel for universeClass.");
      ExceptionHandler.instance().handle(e);
      e.printStackTrace();
    }

  }

  public void setUniverseClass(DataTreeNode dataTreeNode) {
    universeclass = (Universeclass) dataTreeNode.getRockDBObject();
  }

  public void setDataModelController(DataModelController dataModelController) {
    this.dataModelController = dataModelController;
  }

  public UniverseClassTableModel getUCTableModel() {
    return uctm;
  }

  public Object[] getTechPacks() {

    try {

      Versioning ver = new Versioning(etlRock);
      VersioningFactory verF = new VersioningFactory(etlRock, ver);

      Object[] result = new Object[verF.get().size()];
      for (int i = 0; i < verF.get().size(); i++) {
        Versioning v = (Versioning) verF.get().get(i);
        result[i] = (v.getTechpack_name() + ":" + v.getTechpack_version());
      }

      return result;

    } catch (Exception e) {
      ExceptionHandler.instance().handle(e);
      e.printStackTrace();
    }
    return null;
  }

  private UniverseClassTableModel createUCTableModel(Versioning v) throws RockException, SQLException {

    Vector<Universeclass> ucv = new Vector<Universeclass>();
    if (v != null) {
      Universeclass UC = new Universeclass(etlRock);
      UC.setVersionid(v.getVersionid());
      UniverseclassFactory UCF = new UniverseclassFactory(etlRock, UC, "order by ordernro");

      // Filter meastype autogenerated classes out
      for (Iterator<Universeclass> i = UCF.get().iterator(); i.hasNext();) {
        Universeclass u = i.next();
        if (u != null && (u.getOrdernro() == null || u.getOrdernro() != Long.MAX_VALUE)) {
          ucv.add(u);
        }
      }
    }

    UniverseClassTableModel newModel = new UniverseClassTableModel(ucv, etlRock);

    return newModel;
  }

  public void refresh(Versioning v) {
    try {
      this.versioning = v;
      this.uctm = createUCTableModel(v);
    } catch (Exception e) {
      logger.warning("Could not refresh UniverseClass.");
      ExceptionHandler.instance().handle(e);
      e.printStackTrace();
    }
  }

  public void refresh() {
    refresh(null);
  }

  public RockFactory getRockFactory() {
    return etlRock;
  }

  public String getVersionid() {

    if (universeclass == null) {
      return "";
    }
    return universeclass.getVersionid();
  }

  public String getUniverseextension() {

    if (universeclass == null) {
      return "";
    }
    return universeclass.getUniverseextension();
  }

  public String getDescription() {

    if (universeclass == null) {
      return "";
    }
    return universeclass.getDescription();
  }

  public String getParent() {

    if (universeclass == null) {
      return "";
    }
    return universeclass.getParent();
  }

  /**
   * Saves to database
   */
  public void save() throws Exception {

    // Get TP Versionid and throw if it is empty
    String vrVersionid = versioning.getVersionid();
    if (vrVersionid == null || vrVersionid.equals(""))
      throw new Exception("Trying to save without versionID");

    // First remove all this versionId and also all related objects.
    // NOTE: Hidden universe classes with ordernro with maxlong value are not
    // touched.
    List<Universecomputedobject> computedobjects = new ArrayList<Universecomputedobject>();
    List<Universeobject> objects = new ArrayList<Universeobject>();
    List<Universecondition> conditions = new ArrayList<Universecondition>();
    List<Universeparameters> parameters = new ArrayList<Universeparameters>();
    try {
      Universeclass delUC = new Universeclass(etlRock);
      delUC.setVersionid(vrVersionid);
      UniverseclassFactory delUCF = new UniverseclassFactory(etlRock, delUC);
      Iterator<Universeclass> deliter = delUCF.get().iterator();

      while (deliter.hasNext()) {
        Universeclass tmpdelUC = (Universeclass) deliter.next();

        // Delete classes (excluding hidden ones)
        if (tmpdelUC.getOrdernro() == null || tmpdelUC.getOrdernro() != Long.MAX_VALUE) {

          // Get the list of universe computed objects, universe objects, and
          // universe conditions related to the universe class. Also get a list
          // of universe parameters related to the universe computed objects.
          List<Universecomputedobject> colist = getUniverseComputedObjectList(tmpdelUC);
          List<Universeobject> olist = getUniverseObjectList(tmpdelUC);
          List<Universecondition> clist = getUniverseConditionList(tmpdelUC);
          List<Universeparameters> plist = getUniverseParametersList(colist);

          // Remove the related objects
          for (Universeparameters params : plist) {
            parameters.add((Universeparameters) params.clone());
            params.deleteDB();
          }
          for (Universecomputedobject computed : colist) {
            computedobjects.add((Universecomputedobject) computed.clone());
            computed.deleteDB();
          }
          for (Universeobject object : olist) {
            objects.add((Universeobject) object.clone());
            object.deleteDB();
          }
          for (Universecondition condition : clist) {
            conditions.add((Universecondition) condition.clone());
            condition.deleteDB();
          }

          // Remove the universe class
          tmpdelUC.deleteDB();
        }
      }
    } catch (Exception e) {
      e.printStackTrace();
      throw e;
    }

    // Then add the ones on the Screen and all the related objects which still
    // have a valid relation.
    try {
      UniverseClassTableModel tableModel = getUCTableModel();
      for (Universeclass uc : tableModel.data) {

        if (!vrVersionid.equals(uc.getVersionid()))
          throw new Exception("Trying to save for wrong versionId");

        uc.insertDB();

        // Add all the related objects with existing relationship:
        // Add universe objects.
        for (Universeobject uo : objects) {
          if (uc.getClassname().equals(uo.getClassname()) && uc.getVersionid().equals(uo.getVersionid())
              && uc.getUniverseextension().equals(uo.getUniverseextension()))
            uo.insertDB();
        }
        // Add universe computed objects (and their related universe
        // parameters).
        for (Universecomputedobject uco : computedobjects) {
          if (uc.getClassname().equals(uco.getClassname()) && uc.getVersionid().equals(uco.getVersionid())
              && uc.getUniverseextension().equals(uco.getUniverseextension())) {
            uco.insertDB();

            // Add the related universe parameters related to this universe
            // computed object.
            for (Universeparameters up : parameters) {
              if (uco.getClassname().equals(up.getClassname()) && uco.getVersionid().equals(up.getVersionid())
                  && uco.getUniverseextension().equals(up.getUniverseextension())
                  && uco.getObjectname().equals(up.getObjectname()))
                up.insertDB();
            }
          }
        }
        // Add universe conditions.
        for (Universecondition ucond : conditions) {
          if (uc.getClassname().equals(ucond.getClassname()) && uc.getVersionid().equals(ucond.getVersionid())
              && uc.getUniverseextension().equals(ucond.getUniverseextension()))
            ucond.insertDB();
        }

      }
    } catch (Exception e) {
      System.out.println(e);
      throw e;
    }
  }

  /**
   * Gets related list of universe conditions.
   * 
   * @param uc
   * @return
   * @throws Exception
   */
  List<Universecondition> getUniverseConditionList(Universeclass uc) throws Exception {
    List<Universecondition> condList = new ArrayList<Universecondition>();
    try {
      Universecondition U = new Universecondition(etlRock);
      U.setVersionid(uc.getVersionid());
      U.setClassname(uc.getClassname());
      U.setUniverseextension(uc.getUniverseextension());
      UniverseconditionFactory F = new UniverseconditionFactory(etlRock, U);
      condList = F.get();
    } catch (Exception e) {
      throw e;
    }
    return condList;
  }

  /**
   * Gets related list of universeobjects
   * 
   * @param uc
   * @return
   * @throws Exception
   */
  List<Universeobject> getUniverseObjectList(Universeclass uc) throws Exception {
    List<Universeobject> objList = new ArrayList<Universeobject>();
    try {
      Universeobject U = new Universeobject(etlRock);
      U.setVersionid(uc.getVersionid());
      U.setClassname(uc.getClassname());
      U.setUniverseextension(uc.getUniverseextension());
      UniverseobjectFactory F = new UniverseobjectFactory(etlRock, U);
      objList = F.get();
    } catch (Exception e) {
      throw e;
    }
    return objList;
  }

  /**
   * Gets related list of universecomputedobjects
   * 
   * @param uc
   * @return
   * @throws Exception
   */
  List<Universecomputedobject> getUniverseComputedObjectList(Universeclass uc) throws Exception {
    List<Universecomputedobject> compObjList = new ArrayList<Universecomputedobject>();
    try {
      Universecomputedobject U = new Universecomputedobject(etlRock);
      U.setVersionid(uc.getVersionid());
      U.setClassname(uc.getClassname());
      U.setUniverseextension(uc.getUniverseextension());
      UniversecomputedobjectFactory F = new UniversecomputedobjectFactory(etlRock, U);
      compObjList = F.get();
    } catch (Exception e) {
      throw e;
    }
    return compObjList;
  }

  /**
   * Gets a list of universe parameters related to the universe computed
   * objects.
   * 
   * @param compObjList
   *          a list of universe computed objects
   * @return a list of universe parameters
   * @throws Exception
   */
  /**
   * @param compObjList
   * @return
   * @throws Exception
   */
  List<Universeparameters> getUniverseParametersList(List<Universecomputedobject> compObjList) throws Exception {

    // Create an empty list of universe parameters
    List<Universeparameters> paramList = new ArrayList<Universeparameters>();

    // Iterate through the universe computed objects. Add the universe
    // parameters for each computed object to the list.
    for (Universecomputedobject compObj : compObjList) {
      try {
        Universeparameters up = new Universeparameters(etlRock);
        up.setVersionid(compObj.getVersionid());
        up.setClassname(compObj.getClassname());
        up.setUniverseextension(compObj.getUniverseextension());
        up.setObjectname(compObj.getObjectname());
        UniverseparametersFactory F = new UniverseparametersFactory(etlRock, up);
        paramList.addAll(F.get());
      } catch (Exception e) {
        throw e;
      }
    }

    // Return the collected list of universe parameters.
    return paramList;
  }

  /**
   * Data validation
   * 
   * @return errormessages
   */
  public Vector<String> validateData() {
    Vector<String> errorStrings = new Vector<String>();
    UniverseClassTableModel tm = getUCTableModel();

    // Check if there is data to validate.
    if (tm == null)
      return null;

    // Iterate through the table data.
    List<Universeclass> ucs = new ArrayList<Universeclass>();
    for (Universeclass uc1 : tm.data) {

      // Replace null values with empty values.
      uc1.removeNulls();

      // Verify that mandatory parameters are not empty
      if (uc1.getClassname().equals("") || uc1.getVersionid().equals("") || uc1.getUniverseextension().equals("")) {
        errorStrings.add("No empty values allowed for Class name or Universe extension.");
      }

      // Verify that there are no duplicate primary keys. A duplicate value is
      // detected if 1) all the primary key column values are the same or 2)
      // when other primary key column values are the same and the universe
      // extension is "ALL" in the other one.
      for (Universeclass uc2 : ucs) {
        if (uc1.dbEquals(uc2)) {
          errorStrings.add("Duplicate entries found with Class name: " + uc1.getClassname() + ".");

        } else if (uc1.getClassname().equals(uc2.getClassname()) && uc1.getVersionid().equals(uc2.getVersionid())
            && (uc1.getUniverseextension().equals("ALL") || uc2.getUniverseextension().equals("ALL"))) {
          // ClassName and VersionId match and one of the tables has extension
          // "ALL"
          errorStrings.add("Duplicate entries found with Class Name " + uc1.getClassname()
              + ". Universe extension 'ALL' is used!");
        }
      }
      ucs.add(uc1);
    }

    return errorStrings;
  }

  public boolean validateNew(RockDBObject rObj) {
    return true;
  }

  public boolean validateDel(RockDBObject rObj) {
    return true;
  }

  public boolean validateMod(RockDBObject rObj) {
    return true;
  }

  public boolean newObj(RockDBObject rObj) {
    try {
      rObj.insertDB();
    } catch (Exception e) {
      ExceptionHandler.instance().handle(e);
      e.printStackTrace();
    }
    return true;
  }

  public boolean delObj(RockDBObject rObj) {
    try {
      rObj.deleteDB();
    } catch (Exception e) {
      ExceptionHandler.instance().handle(e);
      e.printStackTrace();
    }
    return true;
  }

  public boolean modObj(RockDBObject rObj) {
    RockDBObject[] r = new RockDBObject[1];
    r[0] = rObj;
    return modObj(r);
  }

  public boolean modObj(RockDBObject rObj[]) {

    try {

      etlRock.getConnection().setAutoCommit(false);

      for (int i = 0; i < rObj.length; i++) {
        rObj[i].updateDB();
      }

      dataModelController.rockObjectsModified(this);

      etlRock.getConnection().commit();

    } catch (Exception e) {
      try {
        etlRock.getConnection().rollback();
      } catch (Exception sqlE) {
        ExceptionHandler.instance().handle(sqlE);
        sqlE.printStackTrace();
      }
      ExceptionHandler.instance().handle(e);
      e.printStackTrace();
    } finally {
      try {
        etlRock.getConnection().setAutoCommit(true);
      } catch (Exception sqlE) {
        ExceptionHandler.instance().handle(sqlE);
        sqlE.printStackTrace();
      }
    }

    return true;
  }

  public boolean updated(DataModel dataModel) {
    return false;
  }

  public String[] getUniverseExtensions(String versionId) {

    if (versionId == null || versionId.equals(""))
      return null;

    List<String> rowData = new ArrayList<String>();

    for (String defaultStr : Constants.UNIVERSEEXTENSIONTYPES)
      rowData.add(defaultStr);

    try {

      Universename unvname = new Universename(etlRock);
      unvname.setVersionid(versionId);

      UniversenameFactory unvnameF = new UniversenameFactory(etlRock, unvname);

      Iterator<Universename> unvnameIter = unvnameF.get().iterator();

      while (unvnameIter.hasNext()) {
        Universename tmpunivversename = (Universename) unvnameIter.next();
        rowData.add(tmpunivversename.getUniverseextension());
      }
    } catch (Exception e) {
      ExceptionHandler.instance().handle(e);
      e.printStackTrace();
    }
    String[] retVal = new String[rowData.size()];
    for (int i = 0; i < retVal.length; i++)
      retVal[i] = rowData.get(i);

    return retVal;
  }

  /**
   * Confirmation of deleting related objects
   * 
   * @return
   */
  public String isOkToSave() {

    // Get all the classes from db with versioning.
    List<Universeclass> list = new ArrayList<Universeclass>();
    try {
      Universeclass UC = new Universeclass(etlRock);
      UC.setVersionid(versioning.getVersionid());
      UniverseclassFactory UCF = new UniverseclassFactory(etlRock, UC);
      list = UCF.get();
    } catch (Exception e) {
      return "Error in validation.";
    }

    // Create a list of to be removed classes, initially containing all the
    // classes.
    List<Universeclass> removeList = new ArrayList<Universeclass>(list);

    // Iterate through all classes and remove the classes still existing in the
    // model or hidden ones from the list.
    UniverseClassTableModel tableModel = getUCTableModel();
    for (Universeclass check : list) {
      if (check.getOrdernro() != null && check.getOrdernro().equals(Long.MAX_VALUE)) {
        removeList.remove(check);
      } else {
        for (Universeclass uc : tableModel.data) {
          if (check.dbEquals(uc)) {
            removeList.remove(check);
            break;
          }
        }
      }
    }

    // Now the list contains the classes, which relationship to children will be
    // broken. Validate the deletion.
    return UniverseClassDataModel.validateDelete(etlRock, removeList);
  }

  static String validateDelete(RockFactory rock, List<Universeclass> uclist) {

    List<Universecondition> condList = new ArrayList<Universecondition>();
    List<Universeobject> objList = new ArrayList<Universeobject>();
    List<Universecomputedobject> compList = new ArrayList<Universecomputedobject>();
    for (Universeclass uc : uclist) {
      try {
        Universecondition U = new Universecondition(rock);
        U.setVersionid(uc.getVersionid());
        U.setClassname(uc.getClassname());
        U.setUniverseextension(uc.getUniverseextension());
        UniverseconditionFactory F = new UniverseconditionFactory(rock, U);
        condList.addAll(F.get());

        Universeobject O = new Universeobject(rock);
        O.setVersionid(uc.getVersionid());
        O.setClassname(uc.getClassname());
        O.setUniverseextension(uc.getUniverseextension());
        UniverseobjectFactory OF = new UniverseobjectFactory(rock, O);
        objList.addAll(OF.get());

        Universecomputedobject C = new Universecomputedobject(rock);
        C.setVersionid(uc.getVersionid());
        C.setClassname(uc.getClassname());
        C.setUniverseextension(uc.getUniverseextension());
        UniversecomputedobjectFactory CF = new UniversecomputedobjectFactory(rock, C);
        compList.addAll(CF.get());

      } catch (Exception ex) {
        return "Error in validation.";
      }
    }

    if (compList.size() > 0 || condList.size() > 0 || objList.size() > 0) {
      StringBuilder sb = new StringBuilder("");
      sb.append("This action will cause deletion of: \n");
      if (compList.size() > 0)
        sb.append(compList.size() + " row(s) of universecomputedobjects\n");
      if (objList.size() > 0)
        sb.append(objList.size() + " row(s) of universeobjects\n");
      if (condList.size() > 0)
        sb.append(condList.size() + " row(s) of universeconditions\n");

      sb.append("Do you want to continue?");

      return sb.toString();
    }

    return "";
  }

}
